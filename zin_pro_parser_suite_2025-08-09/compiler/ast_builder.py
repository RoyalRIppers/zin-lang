from __future__ import annotations
from typing import Any, List, Optional
from dataclasses import dataclass
from antlr4 import CommonTokenStream

# Generated by ANTLR at runtime (see scripts/gen_parser.*)
from ZinParser import ZinParser
from ZinVisitor import ZinVisitor
from ZinLexer import ZinLexer

from .ast_nodes import *

BIN_MAP = set(['+', '-', '*', '/', '%', '==', '!=', '>', '>=', '<', '<=', '&&', '||'])
ASSIGN_OPS = set(['=', '+=', '-=', '*=', '/='])

class ASTBuilder(ZinVisitor):
    def visitProgram(self, ctx: ZinParser.ProgramContext) -> Program:
        decls = []
        for child in ctx.children or []:
            node = child.accept(self) if hasattr(child, 'accept') else None
            if isinstance(node, list):
                decls.extend(node)
            elif node is not None:
                decls.append(node)
        return Program(decls=decls)

    # --- Declarations & statements (subset sufficient for tests)
    def visitVarDecl(self, ctx: ZinParser.VarDeclContext):
        t = ctx.typeSpec().getText()
        name = ctx.IDENT().getText()
        init = self.visit(ctx.expression()) if ctx.expression() else None
        return VarDecl(type_name=t, name=name, init=init)

    def visitReturnStmt(self, ctx: ZinParser.ReturnStmtContext):
        val = self.visit(ctx.expression()) if ctx.expression() else None
        return Return(value=val)

    def visitPrintStmt(self, ctx: ZinParser.PrintStmtContext):
        return Print(value=self.visit(ctx.expression()))

    def visitSleepStmt(self, ctx: ZinParser.SleepStmtContext):
        return Sleep(value=self.visit(ctx.expression()))

    def visitBlock(self, ctx: ZinParser.BlockContext):
        stmts = []
        for st in ctx.statement():
            stmts.append(self.visit(st))
        return Block(statements=stmts)

    def visitIfStmt(self, ctx: ZinParser.IfStmtContext):
        cond = self.visit(ctx.expression())
        then = self.visit(ctx.block(0))
        otherwise = self.visit(ctx.block(1)) if ctx.block(1) else None
        return If(cond=cond, then=then, otherwise=otherwise)

    def visitWhileStmt(self, ctx: ZinParser.WhileStmtContext):
        cond = self.visit(ctx.expression())
        body = self.visit(ctx.block())
        return While(cond=cond, body=body)

    def visitForStmt(self, ctx: ZinParser.ForStmtContext):
        var = ctx.IDENT().getText()
        start = self.visit(ctx.expression(0))
        end = self.visit(ctx.expression(1))
        body = self.visit(ctx.block())
        return For(var=var, start=start, end=end, body=body)

    def visitFunctionDecl(self, ctx: ZinParser.FunctionDeclContext):
        name = ctx.IDENT().getText()
        params = []
        if ctx.params():
            for p in ctx.params().param():
                t = p.typeSpec().getText()
                n = p.IDENT().getText()
                params.append(FnParam(type_name=t, name=n))
        ret = ctx.returnType().typeSpec().getText() if ctx.returnType() else None
        body = self.visit(ctx.block())
        return FnDecl(name=name, params=params, return_type=ret, body=body)

    # --- Expressions
    def visitPrimary(self, ctx: ZinParser.PrimaryContext):
        if ctx.NUMBER():
            text = ctx.NUMBER().getText()
            if text.startswith("0x"):
                return Literal(int(text, 16))
            return Literal(float(text) if "." in text else int(text))
        if ctx.STRING():
            s = ctx.STRING().getText()
            return Literal(eval(s))  # safe enough for simple escapes
        if ctx.boolean():
            t = ctx.boolean().getText()
            return Literal(True if t in ("true","vrai") else False)
        if ctx.IDENT():
            return Identifier(ctx.IDENT().getText())
        if ctx.expression():
            return self.visit(ctx.expression())
        raise NotImplementedError("primary case")

    def visitUnary(self, ctx: ZinParser.UnaryContext):
        if ctx.getChildCount() == 2 and ctx.getChild(0).getText() in ('!','-','+'):
            op = ctx.getChild(0).getText()
            right = self.visit(ctx.unary())
            return Unary(op=op, right=right)
        return self.visitChildren(ctx)

    def visitMultiplication(self, ctx): return self._bin_chain(ctx)
    def visitAddition(self, ctx): return self._bin_chain(ctx)
    def visitComparison(self, ctx): return self._bin_chain(ctx)
    def visitEquality(self, ctx): return self._bin_chain(ctx)
    def visitLogic_and(self, ctx): return self._bin_chain(ctx)
    def visitLogic_or(self, ctx): return self._bin_chain(ctx)

    def _bin_chain(self, ctx):
        node = self.visit(ctx.getChild(0))
        i = 1
        while i < ctx.getChildCount():
            op = ctx.getChild(i).getText()
            right = self.visit(ctx.getChild(i+1))
            node = Binary(left=node, op=op, right=right)
            i += 2
        return node

    def visitAssignment(self, ctx: ZinParser.AssignmentContext):
        if ctx.getChildCount() >= 3:
            # left may be IDENT (...) for now we assume simple ident
            left = self.visit(ctx.getChild(0))
            op = ctx.getChild(1).getText()
            if op in ASSIGN_OPS:
                return Assign(target=left, op=op, value=self.visit(ctx.getChild(2)))
        return self.visitChildren(ctx)

    def visitCall(self, ctx: ZinParser.CallContext):
        callee = self.visit(ctx.primary())
        for i in range(1, ctx.getChildCount(), 2):
            # '(' args? ')'
            if ctx.getChild(i).getText() == '(':
                args_ctx = ctx.getChild(i+1)
                args = []
                if hasattr(args_ctx, "expression"):
                    for e in args_ctx.expression():
                        args.append(self.visit(e))
                callee = Call(callee=callee, args=args)
        return callee
